<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Paradox Ripple â€“ Visible Cube (Copy-Paste Ready)</title>
  <style>
    :root {
      --bg1: #2b2f3a;
      --bg2: #3a3f4b;
      --accent: #0af;
      --text: #e6f3ff;
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
    }

    #video {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      display: none;
      /* shown only if camera works */
      background: #000;
    }

    canvas {
      position: fixed;
      inset: 0;
      display: block;
      z-index: 1;
      /* canvas above video */
      touch-action: none;
    }

    .banner {
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%) perspective(360px) rotateX(12deg);
      font-weight: 800;
      letter-spacing: 4px;
      color: var(--accent);
      text-shadow: 0 3px 12px #00aaffaa, 0 0 18px #66ccff66;
      z-index: 3;
      user-select: none;
      white-space: nowrap;
      font-size: clamp(18px, 5vw, 32px);
      pointer-events: none;
    }

    .fallback {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      z-index: 3;
      background: #ffffff14;
      border: 1px solid #ffffff33;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      font-size: 14px;
      box-shadow: 0 6px 24px #00000055;
      max-width: calc(100% - 24px);
      text-align: center;
      line-height: 1.35;
      display: none;
      /* shown when camera fails */
    }

    .reset {
      position: fixed;
      right: 14px;
      bottom: 18px;
      z-index: 3;
      background: #0af;
      color: #001822;
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      box-shadow: 0 6px 24px #0008;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div class="banner">PARADOX RIPPLE 1</div>
  <div id="fallback" class="fallback"> Camera not available or permission denied. Showing 3D content without camera.
  </div> <button id="resetBtn" class="reset">Reset View</button> <video id="video" autoplay muted playsinline></video>
  <script
    type="module"> import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js'; import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js'; import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js'; import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js'; const video = document.getElementById('video'); const fallback = document.getElementById('fallback'); const resetBtn = document.getElementById('resetBtn'); // Try to start camera (requires HTTPS or localhost) try { const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false }); video.srcObject = stream; video.style.display = 'block'; } catch (err) { console.warn('Camera not available:', err); fallback.style.display = 'block'; } // Scene const scene = new THREE.Scene(); // Camera const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 1000 ); camera.position.set(0, 0, 4.5); // Renderer const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2)); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(0x2f3441, 1); // visible background even without video document.body.appendChild(renderer.domElement); // Background plane so content is visible even without video const bgPlane = new THREE.Mesh( new THREE.PlaneGeometry(50, 50), new THREE.MeshBasicMaterial({ color: 0x3a4050 }) ); bgPlane.position.z = -10; scene.add(bgPlane); // Cube (MeshNormalMaterial keeps it visible regardless of lights) const cube = new THREE.Mesh( new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshNormalMaterial() ); scene.add(cube); // Lights for text scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(3, 5, 4); scene.add(dir); // 3D text: Paradox Ripple const font = await new Promise((resolve, reject) => { const loader = new FontLoader(); loader.load( 'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', resolve, undefined, reject ); }); const textGeo = new TextGeometry('Paradox Ripple', { font, size: 0.28, height: 0.06, curveSegments: 8, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.008, bevelOffset: 0, bevelSegments: 3 }); textGeo.computeBoundingBox(); textGeo.center(); const textMesh = new THREE.Mesh( textGeo, new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 0.2, roughness: 0.25, emissive: 0x003355, emissiveIntensity: 0.4 }) ); textMesh.position.set(0, 1.3, 0); textMesh.rotation.x = -0.18; scene.add(textMesh); // Orbit controls (we add custom zoom that anchors at pointer) const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.08; controls.enablePan = true; controls.enableZoom = false; // Pinch + wheel zoom that anchors at pointer/midpoint let touchStartDistance = 0; let startZoom = camera.zoom; function getDistance(t1, t2) { return Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY); } function getMidPoint(t1, t2) { return { x: (t1.pageX + t2.pageX) / 2, y: (t1.pageY + t2.pageY) / 2 }; } function screenToWorld(x, y, zNDC = 0.5) { const vec = new THREE.Vector3( (x / window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1, zNDC ); vec.unproject(camera); return vec; } renderer.domElement.addEventListener('touchstart', (e) => { if (e.touches.length === 2) { touchStartDistance = getDistance(e.touches, e.touches); startZoom = camera.zoom; } }, { passive: true }); renderer.domElement.addEventListener('touchmove', (e) => { if (e.touches.length === 2) { e.preventDefault(); const distance = getDistance(e.touches, e.touches); const scaleFactor = distance / touchStartDistance; const mid = getMidPoint(e.touches, e.touches); const worldBefore = screenToWorld(mid.x, mid.y); camera.zoom = THREE.MathUtils.clamp(startZoom * scaleFactor, 0.5, 3.5); camera.updateProjectionMatrix(); const worldAfter = screenToWorld(mid.x, mid.y); camera.position.add(worldBefore.sub(worldAfter)); } }, { passive: false }); renderer.domElement.addEventListener('wheel', (e) => { const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; const worldBefore = screenToWorld(e.clientX, e.clientY); camera.zoom = THREE.MathUtils.clamp(camera.zoom * zoomFactor, 0.5, 3.5); camera.updateProjectionMatrix(); const worldAfter = screenToWorld(e.clientX, e.clientY); camera.position.add(worldBefore.sub(worldAfter)); }, { passive: true }); // Resize window.addEventListener('resize', () => { const w = window.innerWidth, h = window.innerHeight; camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); }); // Reset resetBtn.addEventListener('click', () => { camera.position.set(0, 0, 4.5); camera.zoom = 1; camera.updateProjectionMatrix(); controls.reset(); }); // Animate function animate() { requestAnimationFrame(animate); cube.rotation.x += 0.01; cube.rotation.y += 0.013; controls.update(); renderer.render(scene, camera); } animate(); </script>
</body>

</html>
